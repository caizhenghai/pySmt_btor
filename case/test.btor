
class ConstExp(expType):
    def __init__(self, sortId, val, id):
        self.sortId = sortId
        self.val = val
        self.id = id

    def __str__(self):
        return str(self.val)

    def __repr__(self):
        return str(self.val)

    def __eq__(self, other):
        return isinstance(other,
                          ConstExp) and self.sortId == other.sortId and self.id == other.id and self.val == other.val

    def toPySmt(self, exp_map, sort_map, smt_map):
        sort = sort_map[self.sortId].bv_or_arr
        if isinstance(sort, bvType):
            val = int(self.val, 2)
            smt_map[self.id] = BV(val, sort.len)
            return BV(val, sort.len)
        elif isinstance(sort, ArrayType):
            idx_typ = sort.idx_typ
            val = int(self.val, 2)
            smt_map[self.id] = Array(idx_typ, val)
            return Array(idx_typ, val)

    def preExp(self, sort_map, stm_map):
        return self


class VarExp(expType):
    def __init__(self, sortId, id, name=None):
        self.sortId = sortId
        self.id = id
        if name is None:
            self.name = "node" + str(id)
        else:
            self.name = name

    def __str__(self):

        return self.name

    def __repr__(self):
        return self.name

    def toPySmt(self, exp_map, sort_map, smt_map):
        typename = sort_map[self.sortId].toPySmt(exp_map, sort_map, smt_map)
        name = self.name
        smt_map[self.id] = Symbol(name, typename)
        return Symbol(name, typename)

    def preExp(self, sort_map, stm_map):
        print("执行替换：  替换  node%d   为   %s" % (self.id, str(stm_map[self.id])))
        return stm_map[self.id]


class InputExp(expType):
    def __init__(self, sortId, id, name=None):
        self.sortId = sortId
        self.id = id
        if name is None:
            self.name = "node" + str(id)
        else:
            self.name = name

    def __str__(self):

        return self.name

    def __repr__(self):
        return self.name

    def __eq__(self, other):
        return isinstance(other, InputExp) and self.sortId == other.sortId and self.id == other.id

    def toPySmt(self, exp_map, sort_map, smt_map):
        typename = sort_map[self.sortId].toPySmt(exp_map, sort_map, smt_map)
        name = self.name
        smt_map[self.id] = Symbol(name, typename)
        return Symbol(name, typename)

    def preExp(self, sort_map, stm_map):
        # input不动
        return self


class UifExp(expType):
    def __init__(self, sortId, op, es, id):
        self.sortId = sortId
        self.op = op
        self.es = es
        self.id = id

    def __str__(self):
        return " %s(%s) " % (self.op, ', '.join(str(e) for e in self.es))

    def __repr__(self):
        return " %s(%s) " % (self.op, ', '.join(str(e) for e in self.es))

    def __eq__(self, other):
        return isinstance(other,
                          UifExp) and self.sortId == other.sortId and self.id == other.id and self.es == other.es and self.op == other.op

    def toPySmt(self, exp_map, sort_map, smt_map):
        if self.op == "eq":
            left = self.es[0]
            right = self.es[1]
            left_Smt = smt_map[left.id]
            right_Smt = smt_map[right.id]
            res = Ite(Equals(left_Smt, right_Smt),BV(1,1),BV(0,1))
        elif self.op == "not":
            subExp = self.es[0]
            subExp_Smt = smt_map[subExp.id]
            res = BVNot(subExp_Smt)
        elif self.op == "and":
            left = self.es[0]
            right = self.es[1]
            left_Smt = smt_map[left.id]
            right_Smt = smt_map[right.id]
            res = BVAnd(left_Smt, right_Smt)
        elif self.op == "or":
            left = self.es[0]
            right = self.es[1]
            left_Smt = smt_map[left.id]
            right_Smt = smt_map[right.id]
            res = BVOr(left_Smt, right_Smt)
        elif self.op == "add":
            left = self.es[0]
            right = self.es[1]
            left_Smt = smt_map[left.id]
            right_Smt = smt_map[right.id]
            res = left_Smt + right_Smt
        elif self.op == "concat":
            left = self.es[0]
            right = self.es[1]
            left_Smt = smt_map[left.id]
            right_Smt = smt_map[right.id]
            res = BVConcat(left_Smt, right_Smt)
        elif self.op == "redor":
            # BVRor是reduce吗？
            subExp = self.es[0]
            subExp_Smt = smt_map[subExp.id]
            len = sort_map[subExp.sortId].bv_or_arr.len
            res = BVExtract(subExp_Smt,0,0)
            for i in range(1,len):
                res = BVOr(res,BVExtract(subExp_Smt,i,i) )
        elif self.op == "ult":
            left = self.es[0]
            right = self.es[1]
            left_Smt = smt_map[left.id]
            right_Smt = smt_map[right.id]
            res = Ite(BVULT(left_Smt, right_Smt), BV(1, 1), BV(0, 1))
        else:
            assert "not support"
        smt_map[self.id] = res
        return res

    def preExp(self, sort_map, stm_map):
        es = []
        for e in self.es:
            es.append(e.preExp(sort_map, stm_map))
        return UifExp(self.sortId, self.op, es, self.id)


class UifIndExp(expType):
    def __init__(self, sortId, op, es, id, opNats):
        self.sortId = sortId
        self.op = op
        self.es = es
        self.id = id
        self.opdNats = opNats

    def __str__(self):

        return "%s(%s,%s)" % (self.op, str(self.es), str(self.opdNats))

    def __repr__(self):
        return "%s(%s,%s)" % (self.op, str(self.es), str(self.opdNats))

    def __eq__(self, other):
        return isinstance(other,
                          UifIndExp) and self.sortId == other.sortId and self.id == other.id and self.es == other.es and self.op == other.op and self.opdNats == other.opNats

    def toPySmt(self, exp_map, sort_map, smt_map):
        if self.op == "sext":
            left = self.es
            left_Smt = smt_map[left.id]
            res = BVSExt(left_Smt, self.opdNats[0])
        elif self.op == "uext":
            left = self.es
            left_Smt = smt_map[left.id]
            res = BVZExt(left_Smt, self.opdNats[0])
        elif self.op == "slice":
            left = self.es
            left_Smt = smt_map[left.id]
            res = BVExtract(left_Smt, self.opdNats[1], self.opdNats[0])
        else:
            assert "known"
        smt_map[self.id] = res
        return res

    def preExp(self, sort_map, stm_map):
        es = self.es.preExp(sort_map, stm_map)
        return UifExp(self.sortId, es, self.id, self.opdNats)


class ReadExp(expType):
    def __init__(self, sortId, mem, adr, id):
        self.sortId = sortId
        self.mem = mem
        self.adr = adr
        self.id = id

    def __str__(self):

        return "%s[%s]" % (str(self.mem), str(self.adr))

    def __repr__(self):
        return "%s[%s]" % (str(self.mem), str(self.adr))

    def __eq__(self, other):
        return isinstance(other,
                          ReadExp) and self.sortId == other.sortId and self.mem == other.mem and self.id == other.id and self.adr == other.adr

    def toPySmt(self, exp_map, sort_map, smt_map):
        mem_Smt = smt_map[self.mem.id]
        adr_Smt = smt_map[self.adr.id]
        res = Select(mem_Smt, adr_Smt)
        smt_map[self.id] = res
        return res

    def preExp(self, sort_map, stm_map):
        mem = self.mem.preExp(sort_map, stm_map)
        adr = self.adr.preExp(sort_map, stm_map)
        return ReadExp(self.sortId, mem, adr, self.id)


class IteExp(expType):
    def __init__(self, sortId, b, e1, e2, id):
        self.sortId = sortId
        self.b = b
        self.e1 = e1
        self.e2 = e2
        self.id = id

    def __str__(self):

        return "(if %s then %s else %s)" % (str(self.b), str(self.e1), str(self.e2))

    def __repr__(self):
        return "(?%s:%s,%s)" % (str(self.b), str(self.e1), str(self.e2))

    def __eq__(self, other):
        return isinstance(other,
                          IteExp) and self.sortId == other.sortId and self.b == other.b and self.e1 == other.e1 and self.e2 == other.e2 and self.id == other.id

    def toPySmt(self, exp_map, sort_map, smt_map):
        if self.b.toPySmt(exp_map, sort_map, smt_map).get_type() is BOOL:
            b_Smt = smt_map[self.b.id]
            e1_Smt = smt_map[self.e1.id]
            e2_Smt = smt_map[self.e2.id]
            res = Ite(b_Smt, e1_Smt, e2_Smt)
        else:
            b_Smt = smt_map[self.b.id]
            e1_Smt = smt_map[self.e1.id]
            e2_Smt = smt_map[self.e2.id]
            res = Ite(Equals(b_Smt, BV(1, 1)), e1_Smt, e2_Smt)
        smt_map[self.id] = res
        return res


    def preExp(self, sort_map, stm_map):
        b = self.b.preExp(sort_map, stm_map)
        e1 = self.e1.preExp(sort_map, stm_map)
        e2 = self.e2.preExp(sort_map, stm_map)
        return IteExp(self.sortId, b, e1, e2, self.id)


class StoreExp(expType):
    def __init__(self, sortId, mem, adre, content, id):
        self.sortId = sortId
        self.mem = mem
        self.adre = adre
        self.content = content
        self.id = id

    def __str__(self):
        return "(%s[%s]<=%s)" % (str(self.mem), str(self.adre), str(self.content))

    def __repr__(self):
        return "(%s[%s]<=%s)" % (str(self.mem), str(self.adre), str(self.content))

    def __eq__(self, other):
        return isinstance(other,
                          StoreExp) and self.sortId == other.sortId and self.mem == other.mem and self.adre == other.adre and self.content == other.content and self.id == other.id

    def toPySmt(self, exp_map, sort_map, smt_map):
        mem_Smt = smt_map[self.mem.id]
        adre_Smt = smt_map[self.adre.id]
        content_Smt = smt_map[self.content.id]
        res = Store(mem_Smt, adre_Smt, content_Smt)
        smt_map[self.id] = res
        return res

    def preExp(self, sort_map, stm_map):
        mem = self.mem.preExp(sort_map, stm_map)
        adre = self.adre.preExp(sort_map, stm_map)
        content = self.content.preExp(sort_map, stm_map)
        return StoreExp(self.sortId, mem, adre, content, self.id)


# 存储init信息
class Init():
    def __init__(self, sortId, toInit: expType, initVal: expType, id):
        self.id = id
        self.sortId = sortId
        self.toInit = toInit
        self.initVal = initVal

    def __str__(self):
        return "(initial:%s is %s)" % (str(self.toInit), str(self.initVal))

    def toPySmt(self, exp_map, sort_map, smt_map):
        return self.toInit.toPySmt(exp_map, sort_map, smt_map).Equals(self.initVal.toPySmt(exp_map, sort_map, smt_map))


'''
老师要求的Stament：
    nid:=exp
'''


class Statement():
    def __init__(self, nid: INT, exp: expType):
        self.nid = nid
        self.exp = exp

    def __str__(self):
        return "(next %s : %s)" % (str(self.nid), str(self.exp))

    def toPySmt(self, exp_map, sort_map, smt_map):
        return next_var(exp_map[self.nid].toPySmt(exp_map, sort_map, smt_map)).Equals(
            self.exp.toPySmt(exp_map, sort_map, smt_map))


class PropertyEnum(Enum):
    bad = 0
    constraint = 1
    fair = 2
    output = 3


# 存储bad/constrain...
class Property():
    def __init__(self, kind: str, nExp: expType, id):
        self.id = id
        if kind == "bad":
            self.kind = PropertyEnum.bad
        elif kind == "constraint":
            self.kind = PropertyEnum.constraint
        elif kind == "fair":
            self.kind = PropertyEnum.fair
        elif kind == "output":
            self.kind = PropertyEnum.output
        self.nExp = nExp

    def __str__(self):
        return "%s:\n%s" % (str(self.kind), str(self.nExp))

    def toPySmt(self, exp_map, sort_map, smt_map):
        return self.nExp.toPySmt(exp_map, sort_map, smt_map)
